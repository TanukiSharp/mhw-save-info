@page "/"

@using System.IO;
@using System.Threading;
@using System.Diagnostics;
@using Blazor.FileReader;
@using MHWSaveUtils;

@inject IFileReaderService fileReaderService;

@* Code mostly taken from https://github.com/Tewr/BlazorFileReader/blob/master/src/Demo/Blazor.FileReader.Demo.Common/DragnDropCommon.razor *@

<style>
.@dropTargetClass {
    display:block;
    padding: 20px;
    margin-bottom: 10px;
    border: 1px dashed black;
    border-radius: 5px;
}
.@dropTargetDragClass {
    border-color: dodgerblue;
    font-weight: bold;
}
</style>

<div class="@DropClass" @ref=dropTargetElement @ondrop=OnDrop @ondragenter=OnDragEnter @ondragleave=OnDragLeave>
    Drop your Monster Hunter World save file here. (&lt;SteamDirectory&gt;/userdata/???/582010/remote/SAVEDATA1000)
    @foreach (var fileInfo in FileList)
    {
        <br />@fileInfo.Name
    }
</div>
<br />
<br />
<textarea style="max-width: 100%;" cols="150" rows="20">@Output</textarea>

@code {
    ElementReference dropTargetElement;
    IFileReaderRef dropReference;

    const string dropTargetDragClass = "droptarget-drag";
    const string dropTargetClass = "droptarget";

    private List<string> dropClasses = new List<string>() { dropTargetClass };

    public string DropClass => string.Join(" ", dropClasses);

    string Output { get; set; }
    List<IFileInfo> FileList { get; } = new List<IFileInfo>();

    protected override async Task OnAfterRenderAsync(bool isFirstRender)
    {
        dropReference = fileReaderService.CreateReference(dropTargetElement);
        await dropReference.RegisterDropEventsAsync();
    }

    public async Task ClearFile()
    {
        await dropReference.ClearValue();
        await this.RefreshFileList();
    }

    public void OnDragEnter(EventArgs e)
    {
        dropClasses.Add(dropTargetDragClass);
    }

    public void OnDragLeave(EventArgs e)
    {
        dropClasses.Remove(dropTargetDragClass);
    }

    public async Task OnDrop(EventArgs e)
    {
        Output += "Dropped a file.";
        dropClasses.Remove(dropTargetDragClass);
        this.StateHasChanged();
        await this.RefreshFileList();
        await ReadFile();
    }

    private async Task RefreshFileList()
    {
        this.FileList.Clear();
        foreach (var file in await dropReference.EnumerateFilesAsync())
        {
            var fileInfo = await file.ReadFileInfoAsync();
            this.FileList.Add(fileInfo);
        }
        this.StateHasChanged();
    }

    private static readonly string NewLine = Environment.NewLine;

    private void Log(string str, bool update = true)
    {
        Output += $"[{DateTime.Now.ToString("HH:mm:sss.fff")}] {str}{NewLine}";
        if (update)
            this.StateHasChanged();
    }

    public async Task ReadFile()
    {
        Output = string.Empty;
        this.StateHasChanged();

        foreach (IFileReference file in await dropReference.EnumerateFilesAsync())
        {
            var stream = new MemoryStream();

            Log($"Decrypting save data, this can be long...");

            Stopwatch sw = Stopwatch.StartNew();

            using (Stream inputStream = await file.CreateMemoryStreamAsync())
            {
                await Crypto.ParallelDecryptAsync(inputStream, stream, CancellationToken.None);
            }

            sw.Stop();

            Log($"Decryption done. ({sw.ElapsedMilliseconds} ms)");

            using (var weaponUsageReader = new WeaponUsageReader(stream))
            {
                IEnumerable<WeaponUsageSaveSlotInfo> slots = weaponUsageReader.Read();

                foreach (WeaponUsageSaveSlotInfo slotInfo in slots)
                {
                    string playtime = MiscUtils.PlaytimeToGameString(slotInfo.Playtime);
                    Log($"Name: {slotInfo.Name}, Rank: {slotInfo.Rank}, Play time: {playtime}", false);
                }
            }

            this.StateHasChanged();
        }
    }
}
